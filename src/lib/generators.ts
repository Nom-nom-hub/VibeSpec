import * as fs from 'fs-extra';
import * as path from 'path';
import { VibeSpec, VibeFeature, VibeFlow } from './spec-parser';

/**
 * Generator function type
 */
export type GeneratorFn = (spec: VibeSpec) => string;

/**
 * Markdown generator for spec.yaml
 */
export const generateMarkdown: GeneratorFn = (spec: VibeSpec): string => {
  let output = '';

  // Header
  output += `# ${spec.project || 'Unnamed Project'}\n\n`;

  if (spec.version) {
    output += `**Version:** ${spec.version}\n\n`;
  }

  if (spec.description) {
    output += `${spec.description}\n\n`;
  }

  // Goals
  if (spec.goals && spec.goals.length > 0) {
    output += '## ðŸŽ¯ Goals\n\n';
    spec.goals.forEach((goal, index) => {
      output += `${index + 1}. ${goal}\n`;
    });
    output += '\n';
  }

  // Constraints
  if (spec.constraints && spec.constraints.length > 0) {
    output += '## âš ï¸ Constraints\n\n';
    spec.constraints.forEach((constraint, index) => {
      output += `â€¢ ${constraint}\n`;
    });
    output += '\n';
  }

  // Features
  if (spec.features && spec.features.length > 0) {
    output += '## ðŸš€ Features\n\n';
    spec.features.forEach((feature, index) => {
      output += `### ${index + 1}. ${feature.name}\n\n`;
      if (feature.description) {
        output += `${feature.description}\n\n`;
      }

      // Requirements
      if (feature.requirements && feature.requirements.length > 0) {
        output += '#### Requirements\n\n';
        feature.requirements.forEach((req, reqIndex) => {
          output += `â€¢ ${req}\n`;
        });
        output += '\n';
      }

      // Flows
      if (feature.flows && feature.flows.length > 0) {
        output += '#### Implementation Flows\n\n';
        feature.flows.forEach((flow) => {
          output += `**${flow.name}**\n\n`;
          if (flow.steps && flow.steps.length > 0) {
            flow.steps.forEach((step, stepIndex) => {
              output += `${stepIndex + 1}. ${step}\n`;
            });
          } else {
            output += '*No steps defined*\n';
          }
          output += '\n';
        });
      }
    });
    output += '\n';
  }

  // Footer
  output += '*Generated by VibeSpec*\n';

  return output;
};

/**
 * Plain text generator for spec.yaml
 */
export const generateText: GeneratorFn = (spec: VibeSpec): string => {
  let output = '';

  // Header
  const header = spec.project || 'Unnamed Project';
  output += '='.repeat(header.length + 4) + '\n';
  output += `  ${header}\n`;
  output += '='.repeat(header.length + 4) + '\n\n';

  if (spec.version) {
    output += `Version: ${spec.version}\n`;
  }

  if (spec.description) {
    output += `\n${spec.description}\n\n`;
  }

  // Goals
  if (spec.goals && spec.goals.length > 0) {
    output += 'GOALS\n';
    output += '-'.repeat(5) + '\n';
    spec.goals.forEach((goal, index) => {
      output += `${index + 1}. ${goal}\n`;
    });
    output += '\n';
  }

  // Constraints
  if (spec.constraints && spec.constraints.length > 0) {
    output += 'CONSTRAINTS\n';
    output += '-'.repeat(11) + '\n';
    spec.constraints.forEach((constraint, index) => {
      output += `â€¢ ${constraint}\n`;
    });
    output += '\n';
  }

  // Features
  if (spec.features && spec.features.length > 0) {
    output += 'FEATURES\n';
    output += '-'.repeat(8) + '\n';
    spec.features.forEach((feature, index) => {
      output += `${index + 1}. ${feature.name}\n`;
      output += '-'.repeat(feature.name.length + (index + 1).toString().length + 2) + '\n';

      if (feature.description) {
        output += `${feature.description}\n\n`;
      }

      // Requirements
      if (feature.requirements && feature.requirements.length > 0) {
        output += '  Requirements:\n';
        feature.requirements.forEach((req, reqIndex) => {
          output += `    ${reqIndex + 1}. ${req}\n`;
        });
        output += '\n';
      }

      // Flows
      if (feature.flows && feature.flows.length > 0) {
        output += '  Implementation Flows:\n';
        feature.flows.forEach((flow, flowIndex) => {
          output += `    ${flow.name}:\n`;
          if (flow.steps && flow.steps.length > 0) {
            flow.steps.forEach((step, stepIndex) => {
              output += `      ${stepIndex + 1}. ${step}\n`;
            });
          } else {
            output += `      (No steps defined)\n`;
          }
          output += '\n';
        });
        output += '\n';
      }
    });
    output += '='.repeat(50) + '\n';
  }

  output += '\nGenerated by VibeSpec\n';

  return output;
};

/**
 * Get generator function by format
 */
export const getGenerator = (format: string): GeneratorFn => {
  switch (format.toLowerCase()) {
    case 'markdown':
    case 'md':
      return generateMarkdown;
    case 'text':
    case 'txt':
      return generateText;
    default:
      throw new Error(`Unsupported format: ${format}. Supported: md, txt`);
  }
};

/**
 * Write generated output to file or directory
 */
export const writeOutput = async (
  content: string,
  spec: VibeSpec,
  outputPath?: string,
  format: string = 'md'
): Promise<void> => {
  if (!outputPath) {
    // Output to stdout
    console.log(content);
    return;
  }

  let filePath: string;

  // If outputPath is a directory, create filename based on project name
  const stats = await fs.stat(outputPath).catch(() => null);
  if (stats?.isDirectory()) {
    const projectName = (spec.project || 'project').toLowerCase().replace(/[^a-z0-9]/g, '-');
    const extension = format === 'md' ? 'md' : 'txt';
    filePath = path.join(outputPath, `${projectName}-spec.${extension}`);
  } else {
    filePath = outputPath;
  }

  // Ensure directory exists
  await fs.ensureDir(path.dirname(filePath));

  // Write the file
  await fs.writeFile(filePath, content);
};